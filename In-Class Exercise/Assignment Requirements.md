# In-Class Exercise

## ICE1

### ICE1_1.
> 输入3个单词, 按字典顺序输出. Tip: string类型不仅支持’+’操作, 也支持比较运算.

### ICE1_2.
> 火车从始发站（第 1 站）开出，在始发站上车的人数为 a，然后到达第 2 站，在第 2 站有人上、下车，但上、下车的人数相同，因此在第 2 站开出时车上的人数保持为 a 人。从第 3 站起，上、下车的人数有如下规律：上车的人数都是前两站上车人数之和，而下车人数等于上一站上车人数，一直到终点站的前一站。已知：共有 n 个车站，始发站上车的人数为 a ，终点站全部下车的人数是 m 。试问 第 x 站开出时车上的人数是多少？程序运行时，先输入四个整数：始发站上车人数 a，车站数 n，终点站下车人数 m 和所求的站点编号 x。要求输出从 x 站开出时车上的人数。

## ICE2

### ICE2_1.
> 编写程序, 输入若干城市及气温, 输出与平均气温相差最大和最小的城市名称、气温以及偏差值. 给定主函数如下:
```C++
int main()
{
    vector<city_temp> cities;
    cout << "Enter city names and temperatures: " << endl;
    read(cin, cities);  //读入城市和温度数据
    try {
        double avg = average(cities);  //求平均温度(含抛出异常)
        deviate(cities, avg);  //求温度偏差并按偏差排序
        print(cout, cities, avg);  //按要求输出
    }
    catch (domain_error e) {
        cout << e.what() << endl;
    }
    return 0;
}
```
> 要求:
>> 1) 定义相关功能函数, 注意形参类型;
>> 2) 将程序组织为1个头文件+1个源程序文件
>> 
> 测试数据如下:
>> 第一组
```C++
Shanghai 20
Guangzhou 28
Beijing 21
Hangzhou 21
Chengdu 19
Urumqi 12
Kunming 21
Xiamen 25
Lhasa 15
Harbin 10
Sanya 28
```
>> 第二组
```C++
Shanghai 20
Guangzhou 26
Beijing 21
Hangzhou 21
Chengdu 19
Urumqi 12
Kunming 21
Xiamen 25
Lhasa 15
Harbin 9
Sanya 28
```

### ICE2_2.
> 负进制数转换. 负进制数指采用负整数作为基数, 例如: -15(十进制)可转换为负二进制数110001.  
> 设计一个程序, 读入一个十进制整数和一个负进制数的基数, 将此十进制整数转换为此负进制下的整数. 限定: -16<=基数<=-2, 如果基数的绝对值超过 10, 则使用英文字母A-F来表示那些大于 9 的数码.

## ICE3
> 编写模板函数selectSort实现对区间[begin, end)之间的元素选择排序.  
> 选择排序的基本思想是: 首先在整个序列中选出最小的元素, 将它与序列的第一个元素交换位置; 然后再次从余下的序列中选出最小的元素, 将其与序列的第二个元素交换位置; …; 直到整个序列完成排序.   
> 要求:
>> 1. 将程序组织为.h文件和.cpp文件;
>> 2. 分别在vector、list和string对象上测试排序函数, 详情参见运行示例. 提示: 各对象包含的元素个数在[10, 20)之间随机生成, 各对象的元素也随机产生.
>> 3. 采用copy函数和输出流迭代器批量输出vector、list和string对象的元素.

## ICE4
> 输入n(0<n<=20), 输出如下方阵(n=4时):

$$
  \begin{matrix}
   1 & 3 & 4 & 10 \\
   2 & 5 & 9 & 11 \\
   6 & 8 & 12 & 15 \\
   7 & 13 & 14 & 16
  \end{matrix}
$$

> 要求使用vector类保存方阵, 定义两个函数:
>> 1) 生成方阵函数;
>> 2) 输出方阵函数
>> 
> [生成方阵的算法]
```C++
for (每条对角线)
    行下标循环n次
        if (列下标在有效范围内)
            填充整数
    颠倒填充方向
```
