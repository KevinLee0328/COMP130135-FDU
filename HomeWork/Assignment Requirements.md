## HW1

### HW1_1.
> 改写第2章"为名字装框输出"程序, 要求由用户输入"框架和问候语之间的空白符个数". 使用string类构造问候语, 使用循环逐个输出星号或空格. 

### HW1_2.
> 编写程序, 输出一系列"*"字符, 分别构成一个正方形, 一个长方形和一个三角形. 各图形的边长由用户输入. 

### HW1_3.
> 编写程序, 输入宝宝出生日期, 计算宝宝百天是哪一天.

## HW2

### HW2_1.
> 编写程序, 统计输入的单词总数以及每个单词的出现次数. 要求:
>> 1. 用函数组织程序, 如: 从输入流读取多个单词的函数, 统计单词出现次数的函数, 输出统计结果的函数, 等等. 注意: 使用常量引用、非常量引用、普通类型做函数形参.
>> 2. 输出单词及出现次数时, 按照最长单词对齐输出.
>> 3. 未输入任何单词时, 函数应抛出异常, 诊断程序应输出相应提示语句.
>> 4. 英文单词大小写无关. 简单起见, 假设输入单词均来自英文字典.

### HW2_2.
> 认真学习第4章内容, 模仿示例完成一个班级某门课程成绩的计算. 要求:
>> 1. 输出时按总评成绩从高到低排序, 按最长名字对齐输出 (没有平时作业成绩记录的学生不输出). 对应该要求, student_info结构中添加'总评成绩'数据成员.
>> 2. 使用C++的异常处理结构处理学生没有平时作业成绩记录的情况. 
>> 3. 将第一个版本的grade函数定义为内联函数.
>> 4. 将程序组织为7个文件(3个头文件+4个源程序文件). 提交时, 打包为1个zip或rar文件.
>> 
> 测试数据如下:
```
Moo 100 100 100 100 100 100 100 100
Moore 75 85 77 59 0 85 75 89
Norman 57 78 73 66 78 70 88 89
Olson 89 86 70 90 55 73 80 84
Peerson 47 70 82 73 50 87 73 71

Russel 72 87 88 54 55 82 69 87
Thomas 90 96 99 99 100 81 97 97
Vaughn 81 97 99 67 40 90 70 96
Westerly 43 98 96 79 100 82 97 96
Miller 75 62

Baker 67 72 73 40 0 78 55 70
Davis 77 70 82 65 70 77 83 81
Edwards 77 72 73 80 90 93 75 90
Franklin 47 70 82 73 50 87 73 71

Jones 77 82 83 50 10 88 65 80
Harris 97 90 92 95 100 87 93 91
Smith 87 92 93 60 0 98 75 90
Carpenter 47 90 92 73 100 87 93 91

Fail1 45 55 65 80 90 70 65 60
Fail2 55 55 65 50 55 60 65 60
Liu 80 90
```

### HW2_3.
> 计算阶乘之和: S=1!+2!+3!+⋯+n! (n≤50).

## HW3

### HW3_1.
> 认真学习课件/课本第5章内容, 在HW2_2的基础上, 计算一个班级某门课程的成绩. 要求:
>> 1. 学生记录从键盘读入, 保存到list<Student_info>对象中.
>> 2. 编写extract_fails函数, 把学生记录按照通过&未通过分为两类.
>> 3. 调用list的成员函数sort对两类学生记录分别排序(按最终成绩从高到低).
>> 4. 分别输出排序后的两类学生记录的姓名和最终成绩(对齐输出).
>> 5. 程序包含median.cpp, grade.cpp, Student_info.cpp, fails_list.cpp, main.cpp及median.h, grade.h, Student_info.h等8个文件.

### HW3_2.
> 寻找2个容器的共同元素, 并按照元素在容器1中的顺序, 输出这些共同元素. 容器的元素可以是任何支持==和!=操作的数据类型. 要求:
>> 1. 查找共同元素的功能定义为模板函数(使用库函数find(...));
>> 2. 输出容器所有元素的功能也定义为模板函数;
>> 3. 分别在元素类型为int的2个vector容器(整数随机生成)和元素类型为string的2个list容器上测试上述2个模板函数;
>> 4. 提交2个文件: 头文件和源程序文件.

### HW3_3.
> 实现如下四个模板函数:
>> 1. accumulate(b, e, t)对迭代器区间[b, e)所指向的值作累加操作, 返回累加结果.
>> 2. max_element(b, e)找到迭代器区间[b, e)所指向的值中最大值, 返回其迭代器.
>> 3. min_element(b, e)找到迭代器区间[b, e)所指向的值中最小值, 返回其迭代器.
>> 4. output(b, e)输出迭代器区间[b, e)所指向的值.
>> 分别在元素类型为int/double/string的容器上, 测试以上四个模板函数. 测试数据均借助随机函数生成.

## HW4

### HW4_1.
> 认真学习第9章, 将第4章的学生成绩程序改写为用class实现. 即, 实现第9章示例.

### HW4_2.
> HW4_2. 定义一个包含年, 月, 日信息的日期类Date, 要求:
>> 1) 将年, 月, 日定义为Date类的私有数据成员.
>> 2) 为Date类定义三个构造函数:
>>> a. 默认构造函数, 将年月日初始化为0;  
>>> b. 带3个参数的构造函数, 分别初始化年月日;  
>>> c. 从输入流读入年月日.  
>>> 
>> 3) 定义三个访问器函数, 分别获得年月日信息. 定义为内联函数.
>> 4) 定义输出日期成员函数, 输出年月日信息.
>> 5) 定义增加1年, 增加1月, 增加1天三个功能函数作为Date类的接口(成员函数).
>> 6) 定义功能函数, 求两个日期对象的相隔天数.
>> 7) 其它与实现相关的功能函数, 如: 判断某年是否为闰年, 判断日期是否有效, etc, 也定义为成员函数.
>> 8) 编写程序使用Date类. 例如:
```
Date d1(2020, 4, 15), d2(2020, 2, 29);
cout << inteval(d1, d2) << endl;  // 计算d1, d2的相隔天数并输出
```
> 注意: 不得出现无效日期! 例如: 以下操作如果不做特殊考虑, 则会出现无效日期,
>> 2020年2月29日->增加1年->2021年2月29日  
>> 2020年1月31日->增加1月->2020年2月31日  
>> 2020年1月31日->增加1日->2020年1月32日  
>> 2020年12月1日->增加1月->2020年13月1日  
>> 2020年12月31日->增加1日->2020年12月32日  
>> 
> 程序中需将类似无效日期转换为有效日期, 如:
>> 2020年2月29日->增加1年->2021年2月28日  
>> 2020年1月31日->增加1月->2020年2月29日  
>> 2020年1月31日->增加1日->2020年2月1日  
>> 2020年12月1日->增加1月->2021年1月1日  
>> 2020年12月31日->增加1日->2021年1月1日  
