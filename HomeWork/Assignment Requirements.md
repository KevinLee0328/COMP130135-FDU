## HW1

### HW1_1.
> 改写第2章"为名字装框输出"程序, 要求由用户输入"框架和问候语之间的空白符个数". 使用string类构造问候语, 使用循环逐个输出星号或空格. 

### HW1_2.
> 编写程序, 输出一系列"*"字符, 分别构成一个正方形, 一个长方形和一个三角形. 各图形的边长由用户输入. 

### HW1_3.
> 编写程序, 输入宝宝出生日期, 计算宝宝百天是哪一天.

## HW2

### HW2_1.
> 编写程序, 统计输入的单词总数以及每个单词的出现次数. 要求:
>> 1. 用函数组织程序, 如: 从输入流读取多个单词的函数, 统计单词出现次数的函数, 输出统计结果的函数, 等等. 注意: 使用常量引用、非常量引用、普通类型做函数形参.
>> 2. 输出单词及出现次数时, 按照最长单词对齐输出.
>> 3. 未输入任何单词时, 函数应抛出异常, 诊断程序应输出相应提示语句.
>> 4. 英文单词大小写无关. 简单起见, 假设输入单词均来自英文字典.

### HW2_2.
> 认真学习第4章内容, 模仿示例完成一个班级某门课程成绩的计算. 要求:
>> 1. 输出时按总评成绩从高到低排序, 按最长名字对齐输出 (没有平时作业成绩记录的学生不输出). 对应该要求, student_info结构中添加'总评成绩'数据成员.
>> 2. 使用C++的异常处理结构处理学生没有平时作业成绩记录的情况. 
>> 3. 将第一个版本的grade函数定义为内联函数.
>> 4. 将程序组织为7个文件(3个头文件+4个源程序文件). 提交时, 打包为1个zip或rar文件.
>> 
> 测试数据如下:
```C++
Moo 100 100 100 100 100 100 100 100
Moore 75 85 77 59 0 85 75 89
Norman 57 78 73 66 78 70 88 89
Olson 89 86 70 90 55 73 80 84
Peerson 47 70 82 73 50 87 73 71

Russel 72 87 88 54 55 82 69 87
Thomas 90 96 99 99 100 81 97 97
Vaughn 81 97 99 67 40 90 70 96
Westerly 43 98 96 79 100 82 97 96
Miller 75 62

Baker 67 72 73 40 0 78 55 70
Davis 77 70 82 65 70 77 83 81
Edwards 77 72 73 80 90 93 75 90
Franklin 47 70 82 73 50 87 73 71

Jones 77 82 83 50 10 88 65 80
Harris 97 90 92 95 100 87 93 91
Smith 87 92 93 60 0 98 75 90
Carpenter 47 90 92 73 100 87 93 91

Fail1 45 55 65 80 90 70 65 60
Fail2 55 55 65 50 55 60 65 60
Liu 80 90
```

### HW2_3.
> 计算阶乘之和: S=1!+2!+3!+⋯+n! (n≤50).

## HW3

### HW3_1.
> 认真学习课件/课本第5章内容, 在HW2_2的基础上, 计算一个班级某门课程的成绩. 要求:
>> 1. 学生记录从键盘读入, 保存到list<Student_info>对象中.
>> 2. 编写extract_fails函数, 把学生记录按照通过&未通过分为两类.
>> 3. 调用list的成员函数sort对两类学生记录分别排序(按最终成绩从高到低).
>> 4. 分别输出排序后的两类学生记录的姓名和最终成绩(对齐输出).
>> 5. 程序包含median.cpp, grade.cpp, Student_info.cpp, fails_list.cpp, main.cpp及median.h, grade.h, Student_info.h等8个文件.

### HW3_2.
> 寻找2个容器的共同元素, 并按照元素在容器1中的顺序, 输出这些共同元素. 容器的元素可以是任何支持==和!=操作的数据类型. 要求:
>> 1. 查找共同元素的功能定义为模板函数(使用库函数find(...));
>> 2. 输出容器所有元素的功能也定义为模板函数;
>> 3. 分别在元素类型为int的2个vector容器(整数随机生成)和元素类型为string的2个list容器上测试上述2个模板函数;
>> 4. 提交2个文件: 头文件和源程序文件.

### HW3_3.
> 实现如下四个模板函数:
>> 1. accumulate(b, e, t)对迭代器区间[b, e)所指向的值作累加操作, 返回累加结果.
>> 2. max_element(b, e)找到迭代器区间[b, e)所指向的值中最大值, 返回其迭代器.
>> 3. min_element(b, e)找到迭代器区间[b, e)所指向的值中最小值, 返回其迭代器.
>> 4. output(b, e)输出迭代器区间[b, e)所指向的值.
>> 分别在元素类型为int/double/string的容器上, 测试以上四个模板函数. 测试数据均借助随机函数生成.

## HW4

### HW4_1.
> 认真学习第9章, 将第4章的学生成绩程序改写为用class实现. 即, 实现第9章示例.

### HW4_2.
> 定义一个包含年, 月, 日信息的日期类Date, 要求:
>> 1) 将年, 月, 日定义为Date类的私有数据成员.
>> 2) 为Date类定义三个构造函数:
>>> a. 默认构造函数, 将年月日初始化为0;  
>>> b. 带3个参数的构造函数, 分别初始化年月日;  
>>> c. 从输入流读入年月日.  
>>> 
>> 3) 定义三个访问器函数, 分别获得年月日信息. 定义为内联函数.
>> 4) 定义输出日期成员函数, 输出年月日信息.
>> 5) 定义增加1年, 增加1月, 增加1天三个功能函数作为Date类的接口(成员函数).
>> 6) 定义功能函数, 求两个日期对象的相隔天数.
>> 7) 其它与实现相关的功能函数, 如: 判断某年是否为闰年, 判断日期是否有效, etc, 也定义为成员函数.
>> 8) 编写程序使用Date类. 例如:
```C++
Date d1(2020, 4, 15), d2(2020, 2, 29);
cout << inteval(d1, d2) << endl;  // 计算d1, d2的相隔天数并输出
```
> 注意: 不得出现无效日期! 例如: 以下操作如果不做特殊考虑, 则会出现无效日期,
>> 2020年2月29日->增加1年->2021年2月29日  
>> 2020年1月31日->增加1月->2020年2月31日  
>> 2020年1月31日->增加1日->2020年1月32日  
>> 2020年12月1日->增加1月->2020年13月1日  
>> 2020年12月31日->增加1日->2020年12月32日  
>> 
> 程序中需将类似无效日期转换为有效日期, 如:
>> 2020年2月29日->增加1年->2021年2月28日  
>> 2020年1月31日->增加1月->2020年2月29日  
>> 2020年1月31日->增加1日->2020年2月1日  
>> 2020年12月1日->增加1月->2021年1月1日  
>> 2020年12月31日->增加1日->2021年1月1日  

## HW5

### HW5_1.
> 在HW4_1的基础上, 完成学生成绩的字母等级计算和输出. 要求:
>> 1) 增加letter_grade函数, 将数值成绩转换为对应的字母等级成绩.
>> 2) 通过读入成绩文件grades, 计算和输出字母等级成绩(不仅输出到屏幕上, 也输出到磁盘文件final中).
>> 3) 将median函数升级为模板函数, 使其不仅可应用于vector类型, 也可用于内置数组, 且元素可以是任何算术类型. 此外, 还要保证调用median函数不会改变元素的先后顺序. 例如: 求vector容器v中元素的中值, median(v.begin(), v.end()); 求数组a中元素的中值, median(a, a+n). Tip: 与标准库容器一样, 迭代器也有一个类型成员value_type, 表示迭代器所指元素的类型.
>> 
> 附: 复旦大学成绩等级评定标准

| 成绩（百分制） | 等级 |
|  :------:  | :----: |
| [90, 100] | A |
| [85, 90) | A- |
| [82, 85) | B+ |
| [78, 82) | B |
| [75, 78) | B- |
| [71, 75) | C+ |
| [66, 71) | C |
| [62, 66) | C- |
| [60, 62) | D |
| <60 | F |

### HW5_2.
> 队列(Queue)是一种简单的线性数据结构, 其特点是: 元素按顺序进入队列, 按顺序退出队列, 先进队的元素先出队, 后进队的元素排在队列尾部, 如同在食堂排队买饭. 队列的基本操作只有两个: 进队, 出队.  
> 设计和实现整数队列Queue类, 并使用Queue类模拟食堂高峰期排队买饭的过程: 进队速度超过出队速度, 当队列人数超出某个阈值, 报警! 要求:
>> 1) 用链表实现队列.
>> 2) 定义构造函数初始化Queue对象.
>> 3) 将进队和出队操作定义为Queue类的成员函数.  
   每进队一个元素, 动态申请一个表元空间(使用new算子), 将该表元链接到队列末尾;  
   每出队一个元素, 动态释放队列首表元(使用delete算子), 更新队列头指针.  
>> 4) 成员函数还包括: 访问队首元素, 访问队尾元素, 获取队列中的元素个数, 判断队列是否为空, 判断队列是否已满, 输出队列等.
>> 
> 假设平均每8s有一人进队, 每25s有一人出队, 排队人数达到50人时报警.  
> 高峰开始时间计为0, 此时窗口已有1人等待买饭, 8s第2人进队,16s第3人进队, 24s第4人进队, 25s第1人买完饭出队, 32s第5人进队, 40s第6人进队, 48s第7人进队, 50s第2人出队, 56s第8人进队, ......  

## HW6

## HW6_1.
> 认真学习第11章, 实现模板类Vec. 用Vec类替代HW5_1程序中的标准库vector类, 使程序仍然正常运行.

## HW6_2.
> 在HW5_2的基础上, 将队列(Queue)类改写为模板类, 即队列中的元素可以是任何类型. 要求改写后, 模拟食堂高峰排队的程序仍然正常运行.  
> 此外, 因为Queue类对象需要分配资源, 所以必须定义copy constructor, destructor和赋值运算符(即对象在复制, 赋值和销毁时的行为). Tips:
>> 1) 模板类的定义和实现均保存于头文件.
>> 2) 为Queue类增加类型定义size_type, 作为成员函数size()的返回值类型.
>> 3) 定义复制链表和删除链表的操作(私有成员函数), 以便copy constructor, destructor和赋值运算符调用.
>> 4) 在main()中添加如下代码, 看看是否能正确运行HW6_2.JPG.
```C++
Queue<int> q1(q), q2; //假设q是原队列
q1.output();
q2 = q1;
q2.output();
```
> PS. 模板类Queue的定义请参考Queue.h. 注意: 简单的成员函数可在类定义内部实现.

